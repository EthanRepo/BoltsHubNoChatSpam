repeat wait() until game:IsLoaded()

local VERSION = "ENGO-PRIVATE"

local GuiLibrary = shared.GuiLibrary
local players = game:GetService("Players")
local lplr = players.LocalPlayer
local workspace = game:GetService("Workspace")
local lighting = game:GetService("Lighting")
local cam = workspace.CurrentCamera
local targetinfo = shared.VapeTargetInfo
local collectionservice = game:GetService("CollectionService")
local uis = game:GetService("UserInputService")
local mouse = lplr:GetMouse()
local robloxfriends = {}
local bedwars = {}
local getfunctions
local origC0 = nil
local matchState = 0
local kit = ""
local antivoidypos = 0
local scaffoldypos = 0
local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or getgenv().request or request
local queueteleport = syn and syn.queue_on_teleport or queue_on_teleport or fluxus and fluxus.queue_on_teleport
local getasset = getsynasset or getcustomasset
local movementControls = require(game:GetService("Players").LocalPlayer.PlayerScripts.PlayerModule):GetControls()

local checkpublicreponum = 0
local checkpublicrepo
checkpublicrepo = function(id)
	local suc, req = pcall(function() return requestfunc({
		Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/CustomModules/"..id..".vape",
		Method = "GET"
	}) end)
	if not suc then
		checkpublicreponum = checkpublicreponum + 1
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Loading CustomModule Failed!, Attempts : "..checkpublicreponum
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			wait(2)
			textlabel:Remove()
		end)
		wait(2)
		return checkpublicrepo(id)
	end
	if req.StatusCode == 200 then
		return req.Body
	end
	return nil
end

--[[ local vertextsize = game:GetService("TextService"):GetTextSize(VERSION, 25, Enum.Font.SourceSans, Vector2.new(99999, 99999))
GuiLibrary["MainGui"].ClickGui.Version.Text = VERSION
GuiLibrary["MainGui"].ClickGui.Version.Position = UDim2.new(1, -(vertextsize.X) - 20, 1, -25)
GuiLibrary["MainGui"].ClickGui.Version.Version.Text = VERSION ]]


local RenderStepTable = {}
local function BindToRenderStep(name, num, func)
	if RenderStepTable[name] == nil then
		RenderStepTable[name] = game:GetService("RunService").RenderStepped:connect(func)
	end
end
local function UnbindFromRenderStep(name)
	if RenderStepTable[name] then
		RenderStepTable[name]:Disconnect()
		RenderStepTable[name] = nil
	end
end


local function createwarning(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "vape/assets/WarningNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
	end)
end


local function createnotification(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "vape/assets/InfoNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	end)
end

local function getcustomassetfunc(path)
	if not isfile(path) then
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Downloading "..path
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			repeat wait() until isfile(path)
			textlabel:Remove()
		end)
		local req = requestfunc({
			Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/"..path:gsub("vape/assets", "assets"),
			Method = "GET"
		})
		writefile(path, req.Body)
	end
	return getasset(path) 
end

local function createwarning(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "vape/assets/WarningNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
	end)
end

local function getItem(itemName)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"] == itemName then
			return v5, i5
		end
	end
	return nil
end

local function getHotbarSlot(itemName)
	for i5, v5 in pairs(bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.hotbar) do
		if v5["item"] and v5["item"]["itemType"] == itemName then
			return i5 - 1
		end
	end
	return nil
end

local function getSword()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("sword") or v5["itemType"]:find("blade") then
			return v5, i5
		end
	end
	return nil
end

local function getBaguette()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("baguette") then
			return v5
		end
	end
	return nil
end

local function getwool()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("wool") then
			return v5["itemType"], v5["amount"], v5["tool"]
		end
	end	
	return nil
end

local function getmineralamount(arg)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match(arg) then
			return v5["amount"]
		end
	end	
	return nil
end


local function getBed(color)
	for i,v in pairs(bedwars["BedTable"]) do
		if v and v:FindFirstChild("Covers") and v.Covers.BrickColor == color then
			return v
		end
	end
	return nil
end

local function getArmor()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("helmet") or v5["itemType"]:match("chestplate") or v5["itemType"]:match("boots") then
			return v5["itemType"]
		end
	end	
	return nil
end

local function teamsAreAlive()
	local alive = false
	for i,v in pairs(game.Teams:GetChildren()) do
		if v.Name ~= "Spectators" and v.Name ~= "Neutral" and v ~= lplr.Team and #v:GetPlayers() > 0 then
			alive = true
		end
	end
	return alive
end

local function scanforbeds()
	local blocktab = game.Workspace.Map.Blocks:GetChildren()
	bedwars["BedTable"] = {}
	for i = 1, #blocktab do
		local obj = blocktab[i]
		if obj.Name == "bed" then
			bedwars["BedTable"][#bedwars["BedTable"] + 1] = obj
			if antivoidypos == 0 then
				antivoidypos = obj.Position.Y
			end
		end
	end  
end

local function randomString()
	local randomlength = math.random(10,100)
	local array = {}

	for i = 1, randomlength do
		array[i] = string.char(math.random(32, 126))
	end

	return table.concat(array)
end

local function getremote(tab)
    for i,v in pairs(tab) do
        if v == "Client" then
            return tab[i + 1]
        end
    end
    return ""
end

getfunctions = function()
	for i,v in pairs(getgc(true)) do
		if type(v) == "table" then
			if rawget(v, "blocksFolder") then
				bedwars["BlockController"] = v
			end
			if rawget(v, "ClientBlockEngine") then
				bedwars["BlockEngine"] = v["ClientBlockEngine"]
			end
			if rawget(v, "BlockEngine") and rawget(v["BlockEngine"], "store") then
				bedwars["BlockEngine2"] = v["BlockEngine"]
			end
			if rawget(v, "BlockPlacer") then
				bedwars["BlockController2"] = v["BlockPlacer"]
			end
			if rawget(v, "BlockBreaker") then
				bedwars["BlockBreaker"] = v["BlockBreaker"]
			end
			if rawget(v, "calculateBlockDamage") then
				bedwars["BlockController3"] = v
			end
			if rawget(v, "getInventory") then
				bedwars["getInventory"] = function(plr)
					local suc, result = pcall(function() return v["getInventory"](plr) end)
					return (suc and result or {
						["items"] = {},
						["armor"] = {},
						["hand"] = nil
					})
				end
			end
			if rawget(v, "Client") and type(v.Client) == "table" then
				local suc = pcall(function() v.Client:Get("PickupItemEvent") end)
				if suc then
					bedwars["ClientHandler"] = v.Client
				end
				local suc2 = pcall(function() v.Client:Get("SelfReport") end)
				if suc2 then
					local old = getmetatable(v.Client)["Get"]
					getmetatable(v.Client)["Get"] = function(Self, remotename)
						if remotename and tostring(remotename):match("SelfReport") then
							return nil
						end
						return old(Self, remotename)
					end
				end
				local suc3 = pcall(function() v.Client:Get("DamageBlock") end)
				if suc3 then
					bedwars["ClientHandlerDamageBlock"] = v.Client
				end
			end
			if rawget(v, "ClientStore") and bedwars["ClientStoreHandler"] == nil then
				bedwars["ClientStoreHandler"] = v.ClientStore
			end
			if rawget(v, "checkForPickup") then
				local remotetab = debug.getconstants(v["checkForPickup"])
				bedwars["PickupTable"] = v
				bedwars["PickupRemote"] = remotetab[#remotetab - 5]
			end
			if rawget(v, "VictorySection") then
				bedwars["VictoryScreen"] = v["VictorySection"]
			end
			if rawget(v, "calculateImportantLaunchValues") then
				bedwars["BowTable"] = v
				bedwars["ShootProjectile"] = getremote(debug.getconstants(debug.getupvalues(v["launchProjectile"])[2]))
			end
			if rawget(v, "kbDirectionStrength") then
				bedwars["KnockbackTable"] = v
			end
			if rawget(v, "KnockbackUtil") then
				bedwars["KnockbackTable2"] = v["KnockbackUtil"]
			end
			if rawget(v, "ViewmodelController") then
				bedwars["ViewmodelController"] = v["ViewmodelController"]
			end
			if rawget(v, "BedwarsShop") then
				bedwars["Shop"] = v["BedwarsShop"]
			end
			if rawget(v, "SoundManager") then
				bedwars["SoundManager"] = v["SoundManager"]
			end
			if rawget(v, "SetSelectedShopItem") then
				bedwars["SetSelectedShopItem"] = v["SetSelectedShopItem"]
			end
			if rawget(v, "getLocalPlayerEntity") then
				bedwars["getEntityTable"] = v
			end
			if rawget(v, "getItemMeta") then
				bedwars["getItemMetadata"] = v["getItemMeta"]
				bedwars["getIcon"] = function(item, showinv)
					local itemmeta = v["getItemMeta"](item["itemType"])
					if itemmeta and showinv then
						return itemmeta.image
					end
					return ""
				end
			end
			if rawget(v, "equipItem") then
				local remotetab = debug.getconstants(v["equipItem"])
				bedwars["changeItem"] = remotetab[#remotetab - 5]
			end
			if rawget(v, "fireCannon") then
                bedwars["CannonRemote"] = debug.getconstant(v["fireCannon"], 3)
            end
			if rawget(v, "JadeHammerController") then
				local constant = debug.getconstant(getmetatable(v["JadeHammerController"])["useJadeHammer"], 13)
				local constant2 = debug.getconstant(debug.getproto(getmetatable(v["JadeHammerController"])["useJadeHammer"], 5), 2)
				bedwars["HammerRemote"] = constant
				bedwars["HammerLandRemote"] = constant2
			end
			if rawget(v, "RavenController") then
				local constants1 = debug.getconstant(getmetatable(v["RavenController"])["spawnRaven"], 8)
				local constants2 = debug.getconstant(debug.getupvalues(getmetatable(v["RavenController"])["detonateRaven"])[2], 2)
				bedwars["RavenSpawnRemote"] = constants1
				bedwars["RavenDetonateRemote"] = constants2
			end
			if rawget(v, "CannonController") then
				bedwars["CannonLocalTable"] = v["CannonController"]
			end
			if rawget(v, "ShieldController") and getmetatable(rawget(v, "ShieldController")) then
				local remotetab = debug.getconstants(debug.getprotos(getmetatable(v["ShieldController"])["raiseShield"])[1])
				bedwars["raiseShield"] = function()
					game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[remotetab[2]]:FireServer({
						["raised"] = true
					})
				end
			end
			if rawget(v, "BigmanController") then
				local protos = debug.getconstants(debug.getprotos(debug.getprotos(v["BigmanController"]["KnitStart"])[2])[1])
				bedwars["TreeRemote"] = protos[#protos - 5]
			end
			if rawget(v, "performHeal") then
				local remotetab = debug.getconstants(v["performHeal"])
				bedwars["GuitarRemote"] = remotetab[#remotetab - 4]
			end
			if rawget(v, "dropItemInHand") then
				bedwars["DropItem"] = v["dropItemInHand"]
				bedwars["DropItemRemote"] = debug.getconstant(v["dropItemInHand"], 8)
			end
			if rawget(v, "SwordController") then
				bedwars["SwordController"] = v["SwordController"]
			end
			if rawget(v, "BalloonController") then
				bedwars["BalloonController"] = v["BalloonController"]
			end
			if rawget(v, "swingSwordAtMouse") then
				bedwars["SwingSword"] = v["swingSwordAtMouse"]
			end
			if rawget(v, "updateHealthbar") then
				bedwars["BlockHealthbar"] = v
			end
			if rawget(v, "lastHitTime") then
				bedwars["BlockHealthbar2"] = v
			end
			if rawget(v, "swingSwordInRegion") then
				bedwars["SwingSwordRegion"] = v["swingSwordInRegion"]
			end
			if rawget(v, "CombatConstant") then
				bedwars["CombatConstant"] = v["CombatConstant"]
			end
			if rawget(v, "attackEntity") then
				bedwars["attackEntity"] = v["attackEntity"]
			end
			if rawget(v, "requestSelfDamage") then
				bedwars["damageTable"] = v
			end
			if rawget(v, "GamePlayerUtil") then
				bedwars["PlayerUtil"] = v["GamePlayerUtil"]
			end
			if rawget(v, "GuidedMissileController") then
				bedwars["fireGuidedProjectile"] = v["GuidedProjectileController"]["fireGuidedProjectile"]
				bedwars["fireGuidedProjectileRemote"] = v["GuidedProjectileController"]["fireGuidedProjectile"]["instance"]
			end
			for i2,v2 in pairs(v) do
				if tostring(i2):match("sprinting") and type(v2) == "boolean" then
					bedwars["sprintTable"] = v
				  end
			end
		end
	end

	if (bedwars["PlayerUtil"] and bedwars["PickupRemote"] and bedwars["Shop"] and bedwars["SoundManager"] and bedwars["SetSelectedShopItem"] and bedwars["ViewmodelController"] and bedwars["GuitarRemote"] and bedwars["BalloonController"] and bedwars["SwingSwordRegion"] and bedwars["CombatConstant"] and bedwars["SwingSword"] and bedwars["BowTable"] and bedwars["getInventory"] and bedwars["raiseShield"] and bedwars["BlockController"] and bedwars["BlockEngine"] and bedwars["BlockController2"] and bedwars["BlockController3"] and bedwars["SwordController"] and bedwars["attackEntity"] and bedwars["damageTable"] and bedwars["sprintTable"]) or (not shared.VapeExecuted) then
		repeat wait() until lplr.Team ~= nil
		local blocktable = bedwars["BlockController2"].new(bedwars["BlockEngine"], getwool())
		bedwars["placeBlock"] = function(newpos)
			blocktable.blockType = getwool()
			if getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, getwool(), Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3)) and getItem(getwool()) then
				bedwars["BlockController2"].placeBlock(blocktable, Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3))
			end
		end
		spawn(function()
			bedwars["BedTable"] = {}
			repeat wait() until matchState ~= 0
			if workspace.MapCFrames:FindFirstChild("1_spawn") then
				antivoidypos = workspace.MapCFrames["1_spawn"].Value.p.Y * 3
			end
			scanforbeds()
		end)
		bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
			if p3.Game ~= p4.Game then
				if p3.Game.matchState ~= p4.Game.matchState then
					matchState = p3.Game.matchState
					if matchState ~= 0 then
						kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
					end
				end
			end
			if p3.Bedwars.kit ~= p4.Bedwars.kit then
				if matchState ~= 0 then
					kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
				end
			end
		end)
		matchState = bedwars["ClientStoreHandler"]:getState().Game.matchState
		if matchState ~= 0 then
			kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
		end
	else
		wait(1)
	--	print(bedwars["assetTable"],bedwars["ZiplineRemote"],bedwars["HitProjectile"],bedwars["FireProjectile"],bedwars["getInventory"],bedwars["raiseShield"],bedwars["BlockController"],bedwars["BlockEngine"],bedwars["BlockController2"],bedwars["SwordController"],bedwars["attackEntity"],bedwars["damageTable"],bedwars["sprintTable"])
		getfunctions()
	end
end

local function runcode(func)
	func()
end

local function makerandom(min, max)
	return Random.new().NextNumber(Random.new(), min, max)
end

local function getblock(pos)
	return bedwars["BlockEngine2"]:getStore():getBlockAt(bedwars["BlockEngine2"]:getBlockPosition(pos))
end

getfunctions()

local function friendCheck(plr, recolor)
	return (recolor and GuiLibrary["ObjectsThatCanBeSaved"]["Recolor visualsToggle"]["Api"]["Enabled"] or (not recolor)) and GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextList"]["Api"]["ObjectList"], plr.Name)
end

local function getPlayerColor(plr)
	return (friendCheck(plr, true) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1) or tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color)
end

shared.vapeteamcheck = function(plr)
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and bedwars["PlayerUtil"].getGamePlayer(lplr):getTeamId() ~= bedwars["PlayerUtil"].getGamePlayer(plr):getTeamId() or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
end

local function targetCheck(plr, check)
	return (check and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("ForceField") == nil or check == false)
end

local function isAlive(plr)
	if plr then
		return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
	end
	return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
end

local localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()

local function switchItem(tool)
	lplr.Character.HandInvItem.Value = tool
	bedwars["ClientHandler"]:Get(bedwars["changeItem"]):CallServerAsync({
		hand = tool
	})
end

local function switchToAndUseTool(block, legit)
	local tool = nil
	local toolnum = 0
	local blockmeta = bedwars["getItemMetadata"](block.Name)
	local blockType = ""
	if blockmeta["block"] and blockmeta["block"]["breakType"] then
		blockType = blockmeta["block"]["breakType"]
	end
	for i,v in pairs(bedwars["getInventory"](lplr)["items"]) do
		local meta = bedwars["getItemMetadata"](v["itemType"])
		if meta["breakBlock"] and meta["breakBlock"][blockType] then
			tool = v
			break
		end
	end
	if tool and (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value ~= tool["tool"]) then
		if legit then
			bedwars["ClientStoreHandler"]:dispatch({
				type = "InventorySelectHotbarSlot", 
				slot = getHotbarSlot(tool["itemType"])
			})
		end
		switchItem(tool["tool"])
	end
end

local function getlastblock(pos, normal)
	local lastfound = nil
	for i = 1, 20 do
		local extrablock = getblock(pos + (Vector3.FromNormalId(normal) * (i * 3)))
		if extrablock and extrablock.Parent ~= nil then
			lastfound = extrablock
		else
			break
		end
	end
	return lastfound
end

local healthbarblocktable = {
	["blockHealth"] = -1,
	["breakingBlockPosition"] = Vector3.new(0, 0, 0)
}
bedwars["breakBlock"] = function(pos, effects, normal)
	local block = (getlastblock(pos, Enum.NormalId[normal]) or getblock(pos))
	local olditem = lplr.Character.HandInvItem.Value
	local blockhealthbarpos = {blockPosition = Vector3.new(0, 0, 0)}
	local blockdmg = 0
	if block and block.Parent ~= nil then
		switchToAndUseTool(block)
		blockhealthbarpos = {
			blockPosition = bedwars["BlockEngine2"]:getBlockPosition(block.Position)
		}
		if healthbarblocktable.blockHealth == -1 or blockhealthbarpos.blockPosition ~= healthbarblocktable.breakingBlockPosition then
			healthbarblocktable.blockHealth = block:GetAttribute("Health")
			healthbarblocktable.breakingBlockPosition = blockhealthbarpos.blockPosition
		end
		blockdmg = bedwars["BlockEngine2"]:calculateBlockDamage(lplr, blockhealthbarpos)
		healthbarblocktable.blockHealth = healthbarblocktable.blockHealth - blockdmg
		if healthbarblocktable.blockHealth < 0 then
			healthbarblocktable.blockHealth = 0
		end
		if effects then
			bedwars["BlockHealthbar"]["updateHealthbar"](bedwars["BlockHealthbar2"], blockhealthbarpos, healthbarblocktable.blockHealth, block:GetAttribute("MaxHealth"), blockdmg)
		end
		bedwars["ClientHandlerDamageBlock"]:Get("DamageBlock"):CallServerAsync({
			blockRef = blockhealthbarpos, 
			hitPosition = block.Position, 
			hitNormal = Vector3.FromNormalId(Enum.NormalId[normal])
		}):andThen(function(p9)
			if olditem then
				switchToAndUseTool(olditem)
			end
		end)
		if effects then
			if healthbarblocktable.blockHealth <= 0 then
				bedwars["BlockHealthbar2"].breakEffect:playBreak(block.Name, blockhealthbarpos.blockPosition, lplr)
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			else
				bedwars["BlockHealthbar2"].breakEffect:playHit(block.Name, blockhealthbarpos.blockPosition, lplr)
			end
		end
	end
	wait(0.3)
end	

local function getEquipped()
	local type = ""
	local obj = (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value or nil)
	if obj then
		if obj.Name:find("sword") or obj.Name:find("blade") or obj.Name:find("baguette") then
			type = "sword"
		end
		if obj.Name:find("wool") then
			type = "block"
		end
		if obj.Name:find("bow") then
			type = "bow"
		end
	end
    return {["Object"] = obj, ["Type"] = type}
end

local function nakedcheck(plr)
	local inventory = bedwars["getInventory"](plr)
	return inventory["armor"][4] ~= nil and inventory["armor"][5] ~= nil and inventory["armor"][6] ~= nil
end

local function isPlayerTargetable(plr, target, friend, team)
    return plr ~= lplr and plr and isAlive(plr) and targetCheck(plr, target) and ((team and plr.Team == lplr.Team) or (team == nil and shared.vapeteamcheck(plr)))
end

local function vischeck(pos, pos2, ignore)
	local vistab = cam:GetPartsObscuringTarget({pos, pos2}, ignore)
	for i,v in pairs(vistab) do
		print(i,v:GetFullName())
	end
	return not unpack(vistab)
end

local function isJumping()
	if lplr.Character.Humanoid.Jump then
		return true
	else
		return false
	end
end

local function GetAllNearestHumanoidToPosition(distance, amount)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end

local function GetAllNearestHumanoidToPosition2(distance, amount, teamcheck)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if (teamcheck and (v ~= lplr and v.Character) or isPlayerTargetable(v, true, true)) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end


local function GetNearestHumanoidToPosition(distance)
	local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, false) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= closest then
                    closest = mag
                    returnedplayer = v
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToMouse(distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and (checkvis == false or checkvis and (vischeck(v.Character, "Head") or vischeck(v.Character, "HumanoidRootPart"))) then
                local vec, vis = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = v
                    end
                end
            end
        end
    end
    return returnedplayer
end
local hitrealremote =  bedwars["ClientHandler"]:Get(getremote(debug.getconstants(shared.backup_attack)))["instance"]
function hitPlayer(plr)
	hitrealremote:InvokeServer({
		["weapon"] = getSword()["tool"],
		["entityInstance"] = plr.Character,
		["validate"] = {
			["raycast"] = {
				["cameraPosition"] = hashvec(cam.CFrame.p), 
				["cursorDirection"] = hashvec(Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)
			},
			["targetPosition"] = hashvec(plr.Character.HumanoidRootPart.Position),
			["selfPosition"] = hashvec(lplr.Character.HumanoidRootPart.Position)
		}
	})
end

function getClosestOutOfTwo(closestTo, one, two)
	local mag1 = (closestTo - one).Magnitude
	local mag2 = (closestTo - two).Magnitude
	if mag1 < 0 then mag1 = -mag1 end
	if mag2 < 0 then mag2 = -mag2 end
	if mag2 > mag1 then
		return one
	else
		return two
	end
end

function getAllBeds()
	local t={}
	for i,v in pairs(game.Workspace.Map.Blocks:GetChildren()) do
		if v.Name == "bed" and v:FindFirstChild("Covers").BrickColor ~= lplr.TeamColor then 
			table.insert(t, v)
		end
	end
	return t
end

local flyspeed = {["Value"] = 1}
local flyverticalspeed = {["Value"] = 1}
local flyupanddown = {["Enabled"] = false}
local flyposy = 0
local flyup = false
local flydown = false
local flypress
local flyendpress
local fly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
    ["Name"] = "FlagFly", 
    ["Function"] = function(callback)
        if callback then
            if isAlive() then
                flyposy = lplr.Character.HumanoidRootPart.CFrame.p.Y
            end
            flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
                if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
                    if input1.KeyCode == Enum.KeyCode.Space then
                        flyup = true
                    end
                    if input1.KeyCode == Enum.KeyCode.LeftShift then
                        flydown = true
                    end
                end
            end)
            flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
                if input1.KeyCode == Enum.KeyCode.Space then
                    flyup = false
                end
                if input1.KeyCode == Enum.KeyCode.LeftShift then
                    flydown = false
                end
            end)
            BindToRenderStep("Fly", 1, function(delta) 
                if isAlive() then
                        if (bodyvelofly ~= nil) then
                            bodyvelofly:Remove()
                        end
                        if flyup then
                            flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
                        end
                        if flydown then
                            flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
                        end
                        local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
                        lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
                        lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                end
            end)
        else
            flyup = false
            flydown = false
            flypress:Disconnect()
            flyendpress:Disconnect()
            UnbindFromRenderStep("Fly")
        end
    end,
})
flyspeed = fly.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyverticalspeed = fly.CreateSlider({
	["Name"] = "Vertical Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyupanddown = fly.CreateToggle({
	["Name"] = "Y Level", 
	["Function"] = function() end,
	["Default"] = true
})

--GuiLibrary["RemoveObject"]("FlagFlyOptionsButton") -- uncomment to remove flagfly

local alarmzones = game:GetService("Workspace"):FindFirstChild("BedAlarmZones")
if alarmzones then
    for i,v in pairs(alarmzones:GetChildren()) do
		v:Remove()
	end
end
lplr.CameraMaxZoomDistance = 200
local clicktpycheck = {["Enabled"] = false}
local clicktpwait = {["Value"] = 0}
local clicktpyset = {["Enabled"] = false}
local clicktpamt = {["Value"] = 0}
local clicktptpback = {["Enabled"] = false}
local ClickTP = {["Enabled"] = false}

bedwars["ClientHandler"]:WaitFor("EntityDamageEvent"):andThen(function(p3)
	p3:Connect(function(p4)
		if ClickTP["Enabled"] and p4.entityInstance == game.Players.LocalPlayer.Character then
			createnotification("Teleportation", "You can now move!", 2)
			movementControls:Enable()
			ClickTP["ToggleButton"](false)
		end
	end)
end)

ClickTP = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
    ["Name"] = "Teleportation", 
    ["Function"] = function(callback) 
        if callback and isAlive() then
			local plrleg = lplr.Character:FindFirstChild("Right Leg") or lplr.Character:FindFirstChild("RightLowerLeg")
			local elevation = math.floor(((plrleg.Position.Y - plrleg.Size.Y/2) - 0.1) * 10) / 10
			local localmouse = lplr:GetMouse()
            local mouseCframe = CFrame.new(localmouse.Hit.p)
			local mousepos = localmouse.Hit.p
			local fromCframe = lplr.Character.HumanoidRootPart.CFrame
			local fromPos = lplr.Character.HumanoidRootPart.Position
			local y = mousepos.Y
			if clicktpmode["Value"] == "Bed" then
				local beds = getAllBeds()
				local bed = beds[math.random(1, #beds)]
				local elevationofBed = math.floor(((bed.Size.Y/2) - 0.1) * 10) / 10
				y = bed.Position.Y
				mouseCframe = bed.CFrame + Vector3.new(6, -elevationofBed, 0)
			elseif clicktpmode["Value"] == "Player" then
				local plr = GetNearestHumanoidToMouse(99999, false)
				y = plr.Character.HumanoidRootPart.Position.Y
				mouseCframe = plr.Character.HumanoidRootPart.CFrame - Vector3.new(0, 3, 0)
			end
			movementControls:Disable()
			for i = 1, 3 do 
				if ClickTP["Enabled"] then
					if clicktpycheck["Enabled"] then 
						if y ~= elevation then
							createnotification("Teleportation", "That Y Level is not good!", 2)
							movementControls:Enable()
							ClickTP["ToggleButton"](false)
							return
						end
					end 
					if clicktptpback["Enabled"] then
						local raycastParams = RaycastParams.new()
						raycastParams.FilterDescendantsInstances = {lplr.Character, game.Workspace:FindFirstChild("Part")}
						raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
						local ray = game.Workspace:Raycast(lplr.Character.HumanoidRootPart.Position, Vector3.new(0, -50, 0), raycastParams)
						if not ray then 
							lplr.Character.HumanoidRootPart.Anchored = true
						end
					end
					lplr.Character.HumanoidRootPart.CFrame = mouseCframe + Vector3.new(0, 3, 0)
					wait(1)
				end
			end
			local waittime = math.floor(((mousepos - fromPos).Magnitude / 40) * 100) / 100
			createnotification("Teleportation", "Waiting "..tostring(waittime).."s", waittime)
			wait(waittime)
			if ClickTP["Enabled"] then
				if y == elevation then
				lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 500, 0)
				end
				wait(1)
				movementControls:Enable()
				ClickTP["ToggleButton"](false)
		end
		elseif not callback then 
			spawn(function()
			wait(10)
			lplr.Character.HumanoidRootPart.Anchored = false
			createnotification("Teleportation", "UnFrozen", 2)
			end)
			movementControls:Enable()
        end
    end, 
    ["HoverText"] = "Slowest TP Method."
})

clicktpmode = ClickTP.CreateDropdown({
	["Name"] = "Mode",
	["List"] = {"Mouse", "Player", "Bed"},
	["Function"] = function(callback) end,
	["Default"] = "Mouse"
})

clicktpycheck = ClickTP.CreateToggle({
	["Name"] = "Y Level Check",
	["Function"] = function(callback) end,
	["HoverText"] = "Checks if your mouse position has\nthe same Y level as your player",
	["Default"] = true
})

clicktptpback = ClickTP.CreateToggle({
	["Name"] = "Anti-Edge",
	["Function"] = function(callback) end,
	["HoverText"] = "Not working"
})

local flyspeed = {["Value"] = 1}
local flyverticalspeed = {["Value"] = 1}
local flyupanddown = {["Enabled"] = false}
local flyposy = 0
local flyup = false
local flydown = false
local flypress
local flyendpress
local DodoFly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "DodoFly", 
	["Function"] = function(callback)
		if callback then
			if isAlive() then
				spawn(function()	
					createwarning("Dodo Fly", "You have 3 seconds left", 1)
					wait(1)
					createwarning("Dodo Fly", "You have 2 seconds left", 1)
					wait(1)
					createwarning("Dodo Fly", "You have 1 second left", 1)
					wait(1)
					createwarning("Dodo Fly", "You have 0 seconds left", 1)
				end)
			flyposy = lplr.Character.HumanoidRootPart.CFrame.p.Y
			end
			flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
				if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
					if input1.KeyCode == Enum.KeyCode.Space then
						flyup = true
					end
					if input1.KeyCode == Enum.KeyCode.LeftShift then
						flydown = true
					end
				end
			end)
			flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
				if input1.KeyCode == Enum.KeyCode.Space then
					flyup = false
				end
				if input1.KeyCode == Enum.KeyCode.LeftShift then
					flydown = false
				end
			end)
			BindToRenderStep("Fly", 1, function(delta) 
				if isAlive() then
						if (bodyvelofly ~= nil) then
							bodyvelofly:Remove()
						end
						if flyup then
							flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
						end
						if flydown then
							flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
						end
						local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
						lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
						lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
				end
			end)
		else
			flyup = false
			flydown = false
			flypress:Disconnect()
			flyendpress:Disconnect()
			UnbindFromRenderStep("Fly")
		end
	end,
})
flyspeed = DodoFly.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyverticalspeed = DodoFly.CreateSlider({
	["Name"] = "Vertical Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyupanddown = DodoFly.CreateToggle({
	["Name"] = "Y Level", 
	["Function"] = function() end,
	["Default"] = true
})

local tptest = {["Enabled"] = false}
tptest = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "glitchy tp thing",
	["Function"] = function(callback) 
		if callback then
			repeat
				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Workspace.SpectatorPlatform.Root.CFrame + Vector3.new(0, -1.5, 0)
				wait()
			until not tptest["Enabled"]
		end
	end
})

local tpthingy = {["Enabled"] = false}
tpthingy = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "glitchy playertp",
	["Function"] = function(callback) 
		if callback then
			local plr = GetNearestHumanoidToPosition(1000000)
			if plr then
			repeat
				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = plr.Character.HumanoidRootPart.CFrame
				wait()
			until not tpthingy["Enabled"]
		else
			print("nope")
		end
	end
end
})

local freeze = {["Enabled"] = false}
freeze = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "freeze",
	["Function"] = function(callback) 
		if callback and isAlive() then
			oldpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
			print("oldpos:",oldpos)
			repeat
				game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldpos
				wait()
			until
			freeze["Enabled"] == false
	end
end
})


--[[ local RocketFly = {["Enabled"] = false}
local flyspeed = {["Value"] = 1}
local flyverticalspeed = {["Value"] = 1}
local flyupanddown = {["Enabled"] = false}
local flyposy = 0
local flyup = false
local flydown = false
local flypress
local flyendpress
local RocketFly = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
	["Name"] = "RocketFly", 
	["Function"] = function(callback)
		if callback then
			if isAlive() then
				if getItem("guided_missile") then
					bedwars["fireGuidedProjectileRemote"]:InvokeServer("guided_missile")
				end
			flyposy = lplr.Character.HumanoidRootPart.CFrame.p.Y
			end
			flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
				if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
					if input1.KeyCode == Enum.KeyCode.Space then
						flyup = true
					end
					if input1.KeyCode == Enum.KeyCode.LeftShift then
						flydown = true
					end
				end
			end)
			flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
				if input1.KeyCode == Enum.KeyCode.Space then
					flyup = false
				end
				if input1.KeyCode == Enum.KeyCode.LeftShift then
					flydown = false
				end
			end)
			BindToRenderStep("RocketFly", 1, function(delta) 
				if isAlive() then
						if (bodyvelofly ~= nil) then
							bodyvelofly:Remove()
						end
						if flyup then
							flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
						end
						if flydown then
							flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
						end
						local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
						local mis = game.Workspace:FindFirstChild("guided_missile")
					if mis then
						game:GetService("Workspace")["guided_missile"].Root.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
						game:GetService("Workspace")["guided_missile"].Root.Velocity = Vector3.new(0, 0, 0)
					else
						print("nope")
					end
					if mis then
						repeat
							game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Workspace")["guided_missile"].Root.CFrame + Vector3.new(0, 4, 0)
							wait()
						until RocketFly["Enabled"] == false
					else
						print("nope")
				end
				end
			end)
		else
			flyup = false
			flydown = false
			flypress:Disconnect()
			flyendpress:Disconnect()
			UnbindFromRenderStep("RocketFly")
		end
	end,
})
flyspeed = RocketFly.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyverticalspeed = RocketFly.CreateSlider({
	["Name"] = "Vertical Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyupanddown = RocketFly.CreateToggle({
	["Name"] = "Y Level", 
	["Function"] = function() end,
	["Default"] = true
}) ]]

--[[ local missiletp1 = {["Enabled"] = false}
local autofire = {["Enabled"] = false}

function tpMissile()
	local m = game.Workspace:FindFirstChild("guided_missile").Root
	local plr = GetNearestHumanoidToPosition(999999)

	repeat 
	wait(0.01)
	m.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
	until not game.Workspace:FindFirstChild("guided_missile") or not missiletp1["Enabled"]
end

missiletp1 = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
	["Name"] = "MissileTP",
	["Function"] = function(callback) 
		if callback then
			if RocketFly["Enabled"] == true then
				RocketFly["ToggleButton"](false)
				wait(0.5)
			end
			missiletp1["ToggleButton"](false)
			if game.Workspace:FindFirstChild("guided_missile") then 
				tpMissile()
			else 
				if autofire["Enabled"] and getItem("guided_missile") then
					bedwars["fireGuidedProjectileRemote"]:InvokeServer("guided_missile")
					tpMissile()
				else
					createwarning("MissileTP", "You need to be using a missile!", 2)
				end
			end
		end
	end,
	["HoverText"] = "Teleports guided missles to closest player",
})

autofire = missiletp1.CreateToggle({
	["Name"] = "AutoFire",
	["Function"] = function(arg) end,
	["HoverText"] = "Automatically fires missiles (if you have them)"
}) ]]

testacdisabler = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Breadcrumbs",
	["Function"] = function(callback) 
		if callback then
			if getItem("balloon") then
			spawn(function()
				createwarning("Breadcrumbs", "Don't move for 5 seconds!", "2")
				movementControls:Disable()
				wait(5)
				createwarning("Breadcrumbs", "You can fly now!", "2")
				movementControls:Enable()
			end)
			bedwars["BalloonController"]["inflateBalloon"]()
			wait(0.6)
			game:GetService("Workspace").Balloons.InflatedBalloon.Balloon.CFrame = CFrame.new(0, -1960, 0)
			game:GetService("Workspace").Balloons.InflatedBalloon.Balloon.BodyForce.Force = Vector3.new(0, -1000, 0)
			spawn(function()
				repeat
					local button = game.Players.LocalPlayer.PlayerGui:FindFirstChild("RoactTree")
					if button then
						button:remove()
						local buttonthere = false
					else
						local buttonthere = true
					end
					wait()
				until buttonthere == false
				end)
				if laggything["Enabled"] == true then
			yes = Instance.new("VectorForce", Workspace)
			yes.Name = "BalloonForce"
			yes.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
			wait(1)
				repeat
					balloonvelo = game.Players.LocalPlayer.Character.HumanoidRootPart:FindFirstChild("BalloonForce")
					if balloonvelo and balloonvelo:IsA("BodyForce") then
						balloonvelo:remove()
						local balloonvelothere = false
					else
						balloonvelothere = false
					end
					wait()
				until balloonvelothere == false
		else
			print("no laggy thing enabled")
		end
			wait(1)
			
			wait(2)
			testacdisabler["ToggleButton"](false)
			else
				print("No Balloon")
			end
		end
	end,
	["HoverText"] = "AnticheatDisabler Yes"
})
laggything = testacdisabler.CreateToggle({
	["Name"] = "remove gravity", 
	["Function"] = function() end,
	["HoverText"] = "Just leave it on lag fixed now",
	["Default"] = true
})

GuiLibrary["RemoveObject"]("HighJumpOptionsButton")
runcode(function()
	local HighJumpBoost = {["Value"] = 1}
	local HighJumpDelay = {["Value"] = 20}
	local HighJumpTick = tick()
	local highjumpbound = true
	local HighJump = {["Enabled"] = false}
	HighJump1 = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
		["Name"] = "HighJump",
		["Function"] = function(callback)
			if callback then
				if HighJumpTick <= tick() and isAlive() and (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) then
					HighJumpTick = tick() + (HighJumpDelay["Value"] / 10)
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, HighJumpBoost["Value"], 0)
					HighJump1["ToggleButton"](false)
				else
					createwarning("LongJump", "Wait "..(math.floor((HighJumpTick - tick()) * 10) / 10).." before retoggling.", 1)
				end
			else

			end
		end, 
		["HoverText"] = "Lets you jump higher (Spamming has a chance to lagback)"
	})
	HighJumpBoost = HighJump1.CreateSlider({
		["Name"] = "Boost",
		["Min"] = 1,
		["Max"] = 1500,
		["Function"] = function(val) end,
		["Default"] = 100
	})
	HighJumpDelay = HighJump1.CreateSlider({
		["Name"] = "Delay",
		["Min"] = 0,
		["Max"] = 50,
		["Function"] = function(val) end, 
		["Default"] = 20
	})
end)

--[[ local testmodule = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "remote test",
	["Function"] = function(callback)
		if callback then
			local args = {
				[1] = lplr.Character.InventoryFolder.Value.rocket_launcher,
				[2] = "rocket_launcher_missile",
				[3] = lplr.Character.HumanoidRootPart.Position,
				[4] = Vector3.new(0, -50, 0)
			}

			game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged.["ShootProjectile"]:InvokeServer(unpack(args))
		end
	end
}) ]]

local function preparetp()
	local groundpos = lplr.Character.HumanoidRootPart.CFrame
	for i = 1,2 do
		lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,1000,0)
		wait(0.5)
	end
	wait(0.1)
		for i = 1,2 do
			lplr.Character.HumanoidRootPart.CFrame = groundpos
			wait(0.1)
		end
	--lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-3)
	wait()
	for i = 1,2 do
		lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-10)
		wait(0.5)
	end
	wait(2.9)
--[[ 				for i = 1,2 do
			lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,7)
			wait(0.3)
			lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-7)
			wait(0.3)
		end ]]
		for i = 1,2 do
			--lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame * CFrame.new(0,5,0)
			wait(0.1)
		end
	end


local hoverboardfly = {["Enabled"] = false}
local flyspeed = {["Value"] = 1}
local flyverticalspeed = {["Value"] = 1}
local flyupanddown = {["Enabled"] = false}
local flyposy = 0
local flyup = false
local flydown = false
local flypress
local flyendpress
local hoverboardfly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
    ["Name"] = "HoverBoard fly", 
    ["Function"] = function(callback)
        if callback then
			if game.Players.LocalPlayer.Character:FindFirstChild("Hoverboard") then
				local nothoverboard = false
				print("hoverboard")
            if isAlive() then
                flyposy = lplr.Character.HumanoidRootPart.CFrame.p.Y
            end
            flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
                if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
                    if input1.KeyCode == Enum.KeyCode.Space then
                        flyup = true
                    end
                    if input1.KeyCode == Enum.KeyCode.LeftShift then
                        flydown = true
                    end
                end
            end)
            flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
                if input1.KeyCode == Enum.KeyCode.Space then
                    flyup = false
                end
                if input1.KeyCode == Enum.KeyCode.LeftShift then
                    flydown = false
                end
            end)
            BindToRenderStep("Fly", 1, function(delta) 
                if isAlive() then
                        if (bodyvelofly ~= nil) then
                            bodyvelofly:Remove()
                        end
                        if flyup then
                            flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
                        end
                        if flydown then
                            flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
                        end
                        local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
                        lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
                        lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                end
            end)
		else
			print("not hoverboard")
			local nothoverboard = true
			createwarning("HoverBoard Fly", "you need to be on a hoverboard!", "2")
		end
        else
			if nothoverboard == false then
            flyup = false
            flydown = false
            flypress:Disconnect()
            flyendpress:Disconnect()
            UnbindFromRenderStep("Fly")
			else
				wait()
			end
        end
    end,
	["HoverText"] = "HoverBoard Exploit Yes",
})
flyspeed = hoverboardfly.CreateSlider({
	["Name"] = "Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyverticalspeed = hoverboardfly.CreateSlider({
	["Name"] = "Vertical Speed",
	["Min"] = 1,
	["Max"] = 150, 
	["Function"] = function(val) end,
	["Default"] = 40
})
flyupanddown = hoverboardfly.CreateToggle({
	["Name"] = "Y Level", 
	["Function"] = function() end,
	["Default"] = true
})

local ClickTPDisableMovement = {["Enabled"] = false}
local ClickTP = {["Enabled"] = false}
ClickTP = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "MouseTP", 
	["Function"] = function(callback) 
		if callback and isAlive() then
			local localmouse = lplr:GetMouse()
			mousehitpos = localmouse.hit.p
			preparetp()
			lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,3,0)
--[[ 			spawn(function()
				local movementControls = require(game:GetService("Players").LocalPlayer.PlayerScripts.PlayerModule):GetControls()
				if ClickTPDisableMovement["Enabled"] == true then
					movementControls:Disable()
					wait(3)
					movementControls:Enable()
				else
					print("Not Enabled")
				end
			end) ]]
			spawn(function()
				wait(3)
				createwarning("Clicktp", "You can now move!", "2")
			end)
			ClickTP["ToggleButton"](false)
		end
	end, 
	["HoverText"] = "Teleports to where your mouse is."
})
ClickTPDisableMovement = ClickTP.CreateToggle({
	["Name"] = "Disable Movement", 
	["Function"] = function() end,
	["Default"] = true
})

local ClickTPPlayer = {["Enabled"] = false}
ClickTPPlayer = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "PlayerTP Yes", 
	["Function"] = function(callback) 
		if callback and isAlive() then
			local nearestplr = GetNearestHumanoidToPosition(99999)
			preparetp()
			lplr.Character.HumanoidRootPart.CFrame = nearestplr.Character.HumanoidRootPart.CFrame
			ClickTPPlayer["ToggleButton"](false)
		end
	end, 
	["HoverText"] = "Teleports to where your mouse is."
})
ClickTPDisableMovement = ClickTPPlayer.CreateToggle({
	["Name"] = "Disable Movement", 
	["Function"] = function() end,
	["Default"] = true
})
PlayerTPMore = ClickTPPlayer.CreateToggle({
	["Name"] = "TP More Than Once", 
	["Function"] = function() end,
	["Default"] = true
})


local bedtp = {["Enabled"] = false}
bedtp = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "Bed TP", 
	["Function"] = function(callback) 
		if callback and isAlive() then
			local beds = getAllBeds()
			local bed = beds[math.random(1, #beds)]
					preparetp()
					lplr.Character.HumanoidRootPart.CFrame = bed.CFrame + Vector3.new(0,7,0)
					bedtp["ToggleButton"](false)
				end
			end, 
	["HoverText"] = "Teleports to where your mouse is."
})

--[[ local donetping
local ClickTP1DisableMovement = {["Enabled"] = false}
local ClickTP1 = {["Enabled"] = false}
ClickTP1 = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
	["Name"] = "MouseTP1", 
	["Function"] = function(callback) 
		if callback and isAlive() then
			movementControls:Disable()
			local oldpos1 = lplr.Character.HumanoidRootPart.Position
			donetping = false
			spawn(function()
				shared.timetaken1 = 0
			repeat
				shared.timetaken1 = shared.timetaken1 + 1
				wait(1)
				until donetping == true
			end)
			local localmouse = lplr:GetMouse()
			mousehitpos = localmouse.hit.p
			preparetp()
				wait(2)
				upy = lplr.Character.HumanoidRootPart.Position.y
				roundedupy = math.floor(upy)
				if roundedoldy == roundedupy then
					createwarning("ClickTP1", "Failed", "2")
					wait(1)
					preparetp()
					lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,20,0)
					wait(0.3)
					lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,10,0)
					wait(0.3)
					lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,3,0)
					wait(1)
					movementControls:Enable()
				else
			lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,20,0)
			wait(0.3)
			lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,10,0)
			wait(0.3)
			lplr.Character.HumanoidRootPart.CFrame = CFrame.new(mousehitpos) + Vector3.new(0,3,0)
			wait(1)
			movementControls:Enable()
				end
			posyes = lplr.Character.HumanoidRootPart.Position.Y
			roundedposyes = math.floor(posyes)
			mousehitpos1 = mousehitpos.Y
			roundedmousehitpos1 = math.floor(mousehitpos1)
			if roundedposyes == roundedmousehitpos1 + 3 then createwarning("MouseTP1", "Success", "2") else createwarning("CickTP1", "Failed", "2") end
			spawn(function()
				wait(3)
				createwarning("Clicktp", "You can now move!", "2")
				local donetping = true
			end)
			createnotification("ClickTP1", shared.timetaken1, "2")
			ClickTP1["ToggleButton"](false)
		end
	end, 
	["HoverText"] = "Teleports to where your mouse is."
})
ClickTP1DisableMovement = ClickTP.CreateToggle({
	["Name"] = "Disable Movement", 
	["Function"] = function() end,
	["Default"] = true
}) ]]
